<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¶ˆæ¶ˆä¹æ¸¸æˆ</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f8ff;
            margin: 0;
            padding: 20px;
        }
        
        header {
            margin-bottom: 20px;
            text-align: center;
        }
        
        h1 {
            color: #4a90e2;
            margin-bottom: 10px;
        }
        
        .game-info {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 500px;
            margin-bottom: 15px;
            background-color: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .score, .moves, .time {
            text-align: center;
        }
        
        #game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-gap: 4px;
            max-width: 500px;
            width: 100%;
            background-color: #e0e0e0;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            position: relative;
        }
        
        .tile {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: transform 0.3s ease, opacity 0.3s ease, background-color 0.3s ease;
            font-size: 24px;
            user-select: none;
            position: relative;
        }
        
        .tile:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }
        
        .selected {
            transform: scale(1.1);
            box-shadow: 0 0 10px gold;
        }
        
        .removing {
            animation: remove-animation 0.5s ease-out;
        }
        
        .dropping {
            animation: drop-animation 0.5s ease-in;
        }
        
        .new-tile {
            animation: new-tile-animation 0.5s ease-out;
        }
        
        @keyframes remove-animation {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(0);
                opacity: 0;
            }
        }
        
        @keyframes drop-animation {
            from {
                transform: translateY(-100%);
            }
            to {
                transform: translateY(0);
            }
        }
        
        @keyframes new-tile-animation {
            from {
                transform: scale(0);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }
        
        button {
            padding: 10px 20px;
            background-color: #4a90e2;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #3a7bc8;
        }
        
        @media (max-width: 500px) {
            #game-board {
                grid-template-columns: repeat(8, 1fr);
                grid-gap: 2px;
                padding: 5px;
            }
            
            .tile {
                font-size: 18px;
            }
            
            .game-info {
                flex-direction: row;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>æ¶ˆæ¶ˆä¹æ¸¸æˆ</h1>
    </header>
    
    <div class="game-info">
        <div class="score">å¾—åˆ†: <span id="score">0</span></div>
        <div class="moves">æ­¥æ•°: <span id="moves">0</span></div>
        <div class="time">æ—¶é—´: <span id="time">60</span>s</div>
    </div>
    
    <div id="game-board"></div>
    
    <div class="controls">
        <button id="new-game">æ–°æ¸¸æˆ</button>
        <button id="hint">æç¤º</button>
    </div>
    
    <script>
        // æ¸¸æˆé…ç½®
        const config = {
            rows: 8,
            cols: 8,
            types: ["ğŸ", "ğŸŠ", "ğŸ‹", "ğŸ‡", "ğŸ‰", "ğŸ“"],
            minMatch: 3,
            timeLimit: 60,
            animationDuration: 500 // åŠ¨ç”»æŒç»­æ—¶é—´(æ¯«ç§’)
        };
        
        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            board: [],
            score: 0,
            moves: 0,
            selected: null,
            timeRemaining: config.timeLimit,
            timer: null,
            gameOver: false,
            animating: false
        };
        
        // DOMå…ƒç´ 
        const boardElement = document.getElementById("game-board");
        const scoreElement = document.getElementById("score");
        const movesElement = document.getElementById("moves");
        const timeElement = document.getElementById("time");
        const newGameButton = document.getElementById("new-game");
        const hintButton = document.getElementById("hint");
        
        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            gameState = {
                board: [],
                visualBoard: [], // è¡¨ç¤ºå½“å‰å¯è§†çŠ¶æ€çš„æ¿
                score: 0,
                moves: 0,
                selected: null,
                timeRemaining: config.timeLimit,
                timer: null,
                gameOver: false,
                hintTimeout: null,
                animating: false
            };
            
            clearTimeout(gameState.hintTimeout);
            scoreElement.textContent = "0";
            movesElement.textContent = "0";
            timeElement.textContent = config.timeLimit;
            
            // åˆ›å»ºæ¸¸æˆæ¿
            createBoard();
            
            // åˆå§‹åŒ–å¯è§†åŒ–æ¸¸æˆæ¿
            gameState.visualBoard = JSON.parse(JSON.stringify(gameState.board));
            
            // æ¸²æŸ“æ¸¸æˆæ¿
            renderBoard();
            
            // å¼€å§‹è®¡æ—¶å™¨
            startTimer();
        }
        
        // åˆ›å»ºæ¸¸æˆæ¿
        function createBoard() {
            for (let row = 0; row < config.rows; row++) {
                gameState.board[row] = [];
                for (let col = 0; col < config.cols; col++) {
                    let type;
                    do {
                        type = getRandomTileType();
                        gameState.board[row][col] = type;
                    } while (checkInitialMatches(row, col));
                }
            }
            
            // ç¡®ä¿æ¸¸æˆæ¿æœ‰å¯è¡Œçš„ç§»åŠ¨
            while (!hasPossibleMoves()) {
                createBoard();
            }
        }
        
        // è·å–éšæœºç“·ç –ç±»å‹
        function getRandomTileType() {
            return config.types[Math.floor(Math.random() * config.types.length)];
        }
        
        // æ£€æŸ¥åˆå§‹åŒ¹é…ï¼ˆé˜²æ­¢æ¸¸æˆå¼€å§‹å°±æœ‰åŒ¹é…ç»„åˆï¼‰
        function checkInitialMatches(row, col) {
            // æ£€æŸ¥æ°´å¹³åŒ¹é…
            if (col >= 2) {
                if (gameState.board[row][col] === gameState.board[row][col-1] && 
                    gameState.board[row][col] === gameState.board[row][col-2]) {
                    return true;
                }
            }
            
            // æ£€æŸ¥å‚ç›´åŒ¹é…
            if (row >= 2) {
                if (gameState.board[row][col] === gameState.board[row-1][col] && 
                    gameState.board[row][col] === gameState.board[row-2][col]) {
                    return true;
                }
            }
            
            return false;
        }
        
        // æ¸²æŸ“æ¸¸æˆæ¿
        function renderBoard() {
            boardElement.innerHTML = "";
            
            for (let row = 0; row < config.rows; row++) {
                for (let col = 0; col < config.cols; col++) {
                    const tile = document.createElement("div");
                    tile.className = "tile";
                    tile.dataset.row = row;
                    tile.dataset.col = col;
                    
                    // è®¾ç½®ç“·ç –é¢œè‰²å’Œå†…å®¹
                    const type = gameState.visualBoard[row]?.[col] || gameState.board[row][col];
                    tile.textContent = type;
                    
                    // è®¾ç½®èƒŒæ™¯é¢œè‰²
                    const colors = {
                        "ğŸ": "#ff6b6b",
                        "ğŸŠ": "#ffa94d",
                        "ğŸ‹": "#ffe066",
                        "ğŸ‡": "#cc5de8",
                        "ğŸ‰": "#20c997",
                        "ğŸ“": "#ff8787"
                    };
                    
                    tile.style.backgroundColor = colors[type] || "#ddd";
                    
                    // è®¾ç½®é€‰ä¸­çŠ¶æ€
                    if (gameState.selected && 
                        gameState.selected.row === row && 
                        gameState.selected.col === col) {
                        tile.classList.add("selected");
                    }
                    
                    // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                    tile.addEventListener("click", () => {
                        if (gameState.gameOver || gameState.animating) return;
                        
                        handleTileClick(row, col);
                    });
                    
                    boardElement.appendChild(tile);
                }
            }
        }
        
        // å¤„ç†ç“·ç –ç‚¹å‡»
        function handleTileClick(row, col) {
            if (gameState.selected) {
                // å¦‚æœå·²ç»æœ‰é€‰ä¸­çš„ç“·ç –ï¼Œæ£€æŸ¥æ˜¯å¦ç›¸é‚»
                const selectedRow = gameState.selected.row;
                const selectedCol = gameState.selected.col;
                
                if (isAdjacent(row, col, selectedRow, selectedCol)) {
                    // äº¤æ¢ç“·ç –
                    swapTiles(row, col, selectedRow, selectedCol);
                    gameState.selected = null;
                } else {
                    // é€‰æ‹©æ–°çš„ç“·ç –
                    gameState.selected = { row, col };
                    renderBoard();
                }
            } else {
                // é€‰æ‹©ç“·ç –
                gameState.selected = { row, col };
                renderBoard();
            }
        }
        
        // æ£€æŸ¥ç“·ç –æ˜¯å¦ç›¸é‚»
        function isAdjacent(row1, col1, row2, col2) {
            return (
                (Math.abs(row1 - row2) === 1 && col1 === col2) ||
                (Math.abs(col1 - col2) === 1 && row1 === row2)
            );
        }
        
        // äº¤æ¢ç“·ç –
        function swapTiles(row1, col1, row2, col2) {
            if (gameState.animating) return;
            gameState.animating = true;
            
            // è§†è§‰ä¸Šäº¤æ¢
            const tile1 = document.querySelector(`[data-row="${row1}"][data-col="${col1}"]`);
            const tile2 = document.querySelector(`[data-row="${row2}"][data-col="${col2}"]`);
            
            // è®°å½•åŸå§‹ä½ç½®
            const tile1Rect = tile1.getBoundingClientRect();
            const tile2Rect = tile2.getBoundingClientRect();
            
            // è®¡ç®—ä½ç§»
            const deltaX = tile2Rect.left - tile1Rect.left;
            const deltaY = tile2Rect.top - tile1Rect.top;
            
            // åº”ç”¨åŠ¨ç”»
            tile1.style.zIndex = "10";
            tile2.style.zIndex = "10";
            tile1.style.transition = `transform 0.3s ease`;
            tile2.style.transition = `transform 0.3s ease`;
            tile1.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            tile2.style.transform = `translate(${-deltaX}px, ${-deltaY}px)`;
            
            // å®é™…äº¤æ¢æ•°æ®
            const temp = gameState.board[row1][col1];
            gameState.board[row1][col1] = gameState.board[row2][col2];
            gameState.board[row2][col2] = temp;
            
            // åŒæ­¥å¯è§†çŠ¶æ€
            gameState.visualBoard = JSON.parse(JSON.stringify(gameState.board));
            
            // åŠ¨ç”»å®Œæˆåæ£€æŸ¥åŒ¹é…
            setTimeout(() => {
                // æ£€æŸ¥äº¤æ¢åæ˜¯å¦æœ‰åŒ¹é…
                const matches = findMatches();
                
                if (matches.length > 0) {
                    // å¢åŠ æ­¥æ•°
                    gameState.moves++;
                    movesElement.textContent = gameState.moves;
                    
                    // æœ‰åŒ¹é…ï¼Œç§»é™¤åŒ¹é…çš„ç“·ç –å¹¶æ›´æ–°å¾—åˆ†
                    removeMatchesWithAnimation(matches);
                } else {
                    // æ²¡æœ‰åŒ¹é…ï¼Œäº¤æ¢å›æ¥
                    const temp = gameState.board[row1][col1];
                    gameState.board[row1][col1] = gameState.board[row2][col2];
                    gameState.board[row2][col2] = temp;
                    
                    // åŒæ­¥å¯è§†çŠ¶æ€
                    gameState.visualBoard = JSON.parse(JSON.stringify(gameState.board));
                    
                    // é‡æ–°åº”ç”¨åŠ¨ç”»ï¼ˆäº¤æ¢å›æ¥ï¼‰
                    tile1.style.transform = "";
                    tile2.style.transform = "";
                    
                    setTimeout(() => {
                        renderBoard();
                        gameState.animating = false;
                    }, 300);
                }
            }, 300);
        }
        
        // æŸ¥æ‰¾åŒ¹é…
        function findMatches() {
            const matches = [];
            
            // æ£€æŸ¥æ°´å¹³åŒ¹é…
            for (let row = 0; row < config.rows; row++) {
                for (let col = 0; col < config.cols - 2; col++) {
                    const type = gameState.board[row][col];
                    if (!type) continue;
                    
                    let matchLength = 1;
                    let nextCol = col + 1;
                    
                    while (nextCol < config.cols && gameState.board[row][nextCol] === type) {
                        matchLength++;
                        nextCol++;
                    }
                    
                    if (matchLength >= config.minMatch) {
                        const match = {
                            type: 'horizontal',
                            row: row,
                            col: col,
                            length: matchLength,
                            positions: []
                        };
                        
                        for (let i = 0; i < matchLength; i++) {
                            match.positions.push({row: row, col: col + i});
                        }
                        
                        matches.push(match);
                    }
                }
            }
            
            // æ£€æŸ¥å‚ç›´åŒ¹é…
            for (let col = 0; col < config.cols; col++) {
                for (let row = 0; row < config.rows - 2; row++) {
                    const type = gameState.board[row][col];
                    if (!type) continue;
                    
                    let matchLength = 1;
                    let nextRow = row + 1;
                    
                    while (nextRow < config.rows && gameState.board[nextRow][col] === type) {
                        matchLength++;
                        nextRow++;
                    }
                    
                    if (matchLength >= config.minMatch) {
                        const match = {
                            type: 'vertical',
                            row: row,
                            col: col,
                            length: matchLength,
                            positions: []
                        };
                        
                        for (let i = 0; i < matchLength; i++) {
                            match.positions.push({row: row + i, col: col});
                        }
                        
                        matches.push(match);
                    }
                }
            }
            
            return matches;
        }
        
        // å¸¦åŠ¨ç”»æ•ˆæœç§»é™¤åŒ¹é…çš„ç“·ç –
        function removeMatchesWithAnimation(matches) {
            let totalRemoved = 0;
            const tilesToRemove = new Set();
            
            // æ”¶é›†æ‰€æœ‰è¦ç§»é™¤çš„ä½ç½®
            matches.forEach(match => {
                match.positions.forEach(pos => {
                    const key = `${pos.row}-${pos.col}`;
                    if (!tilesToRemove.has(key)) {
                        tilesToRemove.add(key);
                        totalRemoved++;
                    }
                });
            });
            
            // æ›´æ–°å¾—åˆ†
            const points = totalRemoved * 10;
            gameState.score += points;
            scoreElement.textContent = gameState.score;
            
            // åº”ç”¨ç§»é™¤åŠ¨ç”»
            tilesToRemove.forEach(key => {
                const [row, col] = key.split('-').map(Number);
                const tile = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (tile) {
                    tile.classList.add('removing');
                }
            });
            
            // æ ‡è®°æ£‹ç›˜ä¸Šè¦ç§»é™¤çš„ä½ç½®
            tilesToRemove.forEach(key => {
                const [row, col] = key.split('-').map(Number);
                gameState.board[row][col] = null;
            });
            
            // ç­‰å¾…ç§»é™¤åŠ¨ç”»å®Œæˆ
            setTimeout(() => {
                // ä¸‹è½ç“·ç –å¹¶å¡«å……æ–°ç“·ç –
                dropTilesWithAnimation();
            }, config.animationDuration);
        }
        
        // å¸¦åŠ¨ç”»æ•ˆæœä¸‹è½ç“·ç –
        function dropTilesWithAnimation() {
            // è®¡ç®—æ¯åˆ—éœ€è¦ä¸‹è½çš„ç“·ç –å’Œæ–°å¢çš„ç“·ç –
            const columnsToProcess = [];
            
            for (let col = 0; col < config.cols; col++) {
                const colInfo = {
                    col: col,
                    drops: [], // éœ€è¦ä¸‹è½çš„ç“·ç – {fromRow, toRow, type}
                    newTiles: []  // æ–°ç”Ÿæˆçš„ç“·ç – {row, type}
                };
                
                // ä»åº•éƒ¨å‘ä¸Šéå†ï¼Œæ ‡è®°ç©ºä½å’Œéœ€è¦ä¸‹è½çš„ç“·ç –
                let emptySpaces = 0;
                for (let row = config.rows - 1; row >= 0; row--) {
                    if (gameState.board[row][col] === null) {
                        emptySpaces++;
                    } else if (emptySpaces > 0) {
                        // è¿™ä¸ªç“·ç –éœ€è¦ä¸‹è½
                        colInfo.drops.push({
                            fromRow: row,
                            toRow: row + emptySpaces,
                            type: gameState.board[row][col]
                        });
                        
                        // æ›´æ–°æ¸¸æˆæ¿
                        gameState.board[row + emptySpaces][col] = gameState.board[row][col];
                        gameState.board[row][col] = null;
                    }
                }
                
                // å¡«å……é¡¶éƒ¨çš„ç©ºä½
                for (let row = 0; row < config.rows; row++) {
                    if (gameState.board[row][col] === null) {
                        const type = getRandomTileType();
                        colInfo.newTiles.push({
                            row: row,
                            type: type
                        });
                        gameState.board[row][col] = type;
                    } else {
                        break; // å·²ç»æ²¡æœ‰ç©ºä½äº†
                    }
                }
                
                columnsToProcess.push(colInfo);
            }
            
            // æ›´æ–°å¯è§†æ¸¸æˆæ¿ï¼Œä½†æš‚æ—¶ä¸æ›´æ–°å°†è¦ä¸‹è½å’Œæ–°å¢çš„ç“·ç –
            gameState.visualBoard = JSON.parse(JSON.stringify(gameState.board));
            
            // å¯¹äºå°†è¦ä¸‹è½çš„ç“·ç –ï¼Œåœ¨å¯è§†æ¿ä¸Šæ¢å¤åŸä½ç½®
            columnsToProcess.forEach(colInfo => {
                colInfo.drops.forEach(drop => {
                    gameState.visualBoard[drop.fromRow][colInfo.col] = drop.type;
                    gameState.visualBoard[drop.toRow][colInfo.col] = null;
                });
                
                colInfo.newTiles.forEach(newTile => {
                    gameState.visualBoard[newTile.row][colInfo.col] = null;
                });
            });
            
            // æ¸²æŸ“ä¸­é—´çŠ¶æ€
            renderBoard();
            
            // åº”ç”¨ä¸‹è½åŠ¨ç”»
            setTimeout(() => {
                // å¯¹æ¯åˆ—åº”ç”¨ä¸‹è½åŠ¨ç”»
                columnsToProcess.forEach(colInfo => {
                    // åº”ç”¨ä¸‹è½åŠ¨ç”»
                    colInfo.drops.forEach(drop => {
                        const tile = document.querySelector(`[data-row="${drop.fromRow}"][data-col="${colInfo.col}"]`);
                        if (tile) {
                            tile.classList.add('dropping');
                            // è®¡ç®—ä¸‹è½è·ç¦»
                            const distance = (drop.toRow - drop.fromRow) * tile.offsetHeight;
                            tile.style.transform = `translateY(${distance}px)`;
                        }
                    });
                });
                
                // ä¸‹è½åŠ¨ç”»å®Œæˆåï¼Œæ¸²æŸ“æœ€ç»ˆçŠ¶æ€å’Œåº”ç”¨æ–°ç“·ç –åŠ¨ç”»
                setTimeout(() => {
                    // æ›´æ–°å¯è§†æ¸¸æˆæ¿ä¸ºå®é™…çŠ¶æ€
                    gameState.visualBoard = JSON.parse(JSON.stringify(gameState.board));
                    renderBoard();
                    
                    // åº”ç”¨æ–°ç“·ç –åŠ¨ç”»
                    columnsToProcess.forEach(colInfo => {
                        colInfo.newTiles.forEach(newTile => {
                            const tile = document.querySelector(`[data-row="${newTile.row}"][data-col="${colInfo.col}"]`);
                            if (tile) {
                                tile.classList.add('new-tile');
                            }
                        });
                    });
                    
                    // æ–°ç“·ç –åŠ¨ç”»å®Œæˆåï¼Œæ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„åŒ¹é…
                    setTimeout(() => {
                        const newMatches = findMatches();
                        if (newMatches.length > 0) {
                            removeMatchesWithAnimation(newMatches);
                        } else if (!hasPossibleMoves()) {
                            // å¦‚æœæ²¡æœ‰å¯èƒ½çš„ç§»åŠ¨ï¼Œé‡æ–°æ´—ç‰Œ
                            shuffleBoard();
                            gameState.animating = false;
                        } else {
                            gameState.animating = false;
                        }
                    }, config.animationDuration);
                }, config.animationDuration);
            }, 50); // çŸ­æš‚å»¶è¿Ÿï¼Œç¡®ä¿DOMæ›´æ–°
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å¯èƒ½çš„ç§»åŠ¨
        function hasPossibleMoves() {
            // ä¸´æ—¶å­˜å‚¨ä¸€ä»½æ¸¸æˆæ¿
            const tempBoard = gameState.board.map(row => [...row]);
            
            // æ£€æŸ¥æ¯ä¸ªå¯èƒ½çš„äº¤æ¢
            for (let row = 0; row < config.rows; row++) {
                for (let col = 0; col < config.cols; col++) {
                    // æ£€æŸ¥å‘å³äº¤æ¢
                    if (col < config.cols - 1) {
                        // äº¤æ¢
                        [gameState.board[row][col], gameState.board[row][col+1]] = 
                        [gameState.board[row][col+1], gameState.board[row][col]];
                        
                        // æ£€æŸ¥åŒ¹é…
                        const matches = findMatches();
                        
                        // äº¤æ¢å›æ¥
                        [gameState.board[row][col], gameState.board[row][col+1]] = 
                        [gameState.board[row][col+1], gameState.board[row][col]];
                        
                        if (matches.length > 0) {
                            // æ¢å¤æ¸¸æˆæ¿å¹¶è¿”å›true
                            gameState.board = tempBoard.map(row => [...row]);
                            return true;
                        }
                    }
                    
                    // æ£€æŸ¥å‘ä¸‹äº¤æ¢
                    if (row < config.rows - 1) {
                        // äº¤æ¢
                        [gameState.board[row][col], gameState.board[row+1][col]] = 
                        [gameState.board[row+1][col], gameState.board[row][col]];
                        
                        // æ£€æŸ¥åŒ¹é…
                        const matches = findMatches();
                        
                        // äº¤æ¢å›æ¥
                        [gameState.board[row][col], gameState.board[row+1][col]] = 
                        [gameState.board[row+1][col], gameState.board[row][col]];
                        
                        if (matches.length > 0) {
                            // æ¢å¤æ¸¸æˆæ¿å¹¶è¿”å›true
                            gameState.board = tempBoard.map(row => [...row]);
                            return true;
                        }
                    }
                }
            }
            
            // æ¢å¤æ¸¸æˆæ¿å¹¶è¿”å›false
            gameState.board = tempBoard.map(row => [...row]);
            return false;
        }
        
        // æ´—ç‰Œæ¸¸æˆæ¿
        function shuffleBoard() {
            if (gameState.animating) return;
            gameState.animating = true;
            
            const allTiles = [];
            
            // æ”¶é›†æ‰€æœ‰ç“·ç –
            for (let row = 0; row < config.rows; row++) {
                for (let col = 0; col < config.cols; col++) {
                    allTiles.push(gameState.board[row][col]);
                }
            }
            
            // æ‰“ä¹±ç“·ç –
            for (let i = allTiles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allTiles[i], allTiles[j]] = [allTiles[j], allTiles[i]];
            }
            
            // ä¿å­˜æ—§æ£‹ç›˜çŠ¶æ€
            const oldBoard = JSON.parse(JSON.stringify(gameState.board));
            
            // é‡æ–°åˆ†é…ç“·ç –
            let index = 0;
            for (let row = 0; row < config.rows; row++) {
                for (let col = 0; col < config.cols; col++) {
                    gameState.board[row][col] = allTiles[index++];
                }
            }
            
            // ç¡®ä¿æ´—ç‰Œåæœ‰å¯è¡Œçš„ç§»åŠ¨
            if (!hasPossibleMoves()) {
                shuffleBoard();
                return;
            }
            
            // æ·»åŠ æ´—ç‰ŒåŠ¨ç”»
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.style.transition = "transform 0.5s ease, opacity 0.2s ease";
                tile.style.transform = "scale(0)";
                tile.style.opacity = "0";
            });
            
            // æ´—ç‰ŒåŠ¨ç”»ç»“æŸåæ˜¾ç¤ºæ–°çš„æ¸¸æˆæ¿
            setTimeout(() => {
                gameState.visualBoard = JSON.parse(JSON.stringify(gameState.board));
                renderBoard();
                
                // æ˜¾ç¤ºæ–°ç“·ç –çš„åŠ¨ç”»
                setTimeout(() => {
                    const newTiles = document.querySelectorAll('.tile');
                    newTiles.forEach(tile => {
                        tile.classList.add('new-tile');
                    });
                    
                    setTimeout(() => {
                        gameState.animating = false;
                    }, config.animationDuration);
                }, 50);
            }, 500);
        }
        
        // å¼€å§‹è®¡æ—¶å™¨
        function startTimer() {
            if (gameState.timer) {
                clearInterval(gameState.timer);
            }
            
            gameState.timer = setInterval(() => {
                gameState.timeRemaining--;
                timeElement.textContent = gameState.timeRemaining;
                
                if (gameState.timeRemaining <= 0) {
                    endGame();
                }
            }, 1000);
        }
        
        // ç»“æŸæ¸¸æˆ
        function endGame() {
            clearInterval(gameState.timer);
            gameState.gameOver = true;
            
            setTimeout(() => {
                alert(`æ¸¸æˆç»“æŸï¼\nä½ çš„å¾—åˆ†ï¼š${gameState.score}\nä½¿ç”¨çš„æ­¥æ•°ï¼š${gameState.moves}`);
            }, 100);
        }
        
        // æç¤ºåŠŸèƒ½
        function showHint() {
            if (gameState.gameOver || gameState.animating) return;
            
            clearTimeout(gameState.hintTimeout);
            
            // æ£€æŸ¥æ¯ä¸ªå¯èƒ½çš„äº¤æ¢
            for (let row = 0; row < config.rows; row++) {
                for (let col = 0; col < config.cols; col++) {
                    // æ£€æŸ¥å‘å³äº¤æ¢
                    if (col < config.cols - 1) {
                        // äº¤æ¢
                        [gameState.board[row][col], gameState.board[row][col+1]] = 
                        [gameState.board[row][col+1], gameState.board[row][col]];
                        
                        // æ£€æŸ¥åŒ¹é…
                        const matches = findMatches();
                        
                        // äº¤æ¢å›æ¥
                        [gameState.board[row][col], gameState.board[row][col+1]] = 
                        [gameState.board[row][col+1], gameState.board[row][col]];
                        
                        if (matches.length > 0) {
                            // æ‰¾åˆ°äº†ä¸€ä¸ªå¯èƒ½çš„ç§»åŠ¨ï¼Œé«˜äº®æ˜¾ç¤º
                            const tile1 = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                            const tile2 = document.querySelector(`[data-row="${row}"][data-col="${col+1}"]`);
                            
                            if (tile1 && tile2) {
                                tile1.classList.add("selected");
                                tile2.classList.add("selected");
                                
                                gameState.hintTimeout = setTimeout(() => {
                                    tile1.classList.remove("selected");
                                    tile2.classList.remove("selected");
                                }, 1000);
                            }
                            
                            return;
                        }
                    }
                    
                    // æ£€æŸ¥å‘ä¸‹äº¤æ¢
                    if (row < config.rows - 1) {
                        // äº¤æ¢
                        [gameState.board[row][col], gameState.board[row+1][col]] = 
                        [gameState.board[row+1][col], gameState.board[row][col]];
                        
                        // æ£€æŸ¥åŒ¹é…
                        const matches = findMatches();
                        
                        // äº¤æ¢å›æ¥
                        [gameState.board[row][col], gameState.board[row+1][col]] = 
                        [gameState.board[row+1][col], gameState.board[row][col]];
                        
                        if (matches.length > 0) {
                            // æ‰¾åˆ°äº†ä¸€ä¸ªå¯èƒ½çš„ç§»åŠ¨ï¼Œé«˜äº®æ˜¾ç¤º
                            const tile1 = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                            const tile2 = document.querySelector(`[data-row="${row+1}"][data-col="${col}"]`);
                            
                            if (tile1 && tile2) {
                                tile1.classList.add("selected");
                                tile2.classList.add("selected");
                                
                                gameState.hintTimeout = setTimeout(() => {
                                    tile1.classList.remove("selected");
                                    tile2.classList.remove("selected");
                                }, 1000);
                            }
                            
                            return;
                        }
                    }
                }
            }
        }
        
        // äº‹ä»¶ç›‘å¬å™¨
        newGameButton.addEventListener("click", initGame);
        hintButton.addEventListener("click", showHint);
        
        // åˆå§‹åŒ–æ¸¸æˆ
        initGame();
    </script>
</body>
</html>
