<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>开心消消乐</title>
    <!-- 引入 Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-image: url('https://www.toptal.com/designers/subtlepatterns/uploads/food.png');
            background-repeat: repeat;
            background-size: 50px 50px;
            margin: 0;
            padding: 20px;
        }
        
        header {
            margin-bottom: 20px;
            text-align: center;
            width: 100%;
            max-width: 500px;
        }
        
        h1 {
            color: #4a90e2;
            margin-bottom: 10px;
            font-family: 'Pacifico', cursive;
            font-size: 36px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            background: linear-gradient(45deg, #4a90e2, #ff6b6b);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .language-selector {
            margin: 10px 0;
        }
        
        .language-btn {
            margin: 0 5px;
            padding: 5px 10px;
            cursor: pointer;
            background-color: #e0e0e0;
            border: none;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        
        .language-btn.active {
            background-color: #4a90e2;
            color: white;
        }
        
        .game-info {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            width: 100%;
            max-width: 500px;
            margin-bottom: 15px;
            background-color: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .score, .moves, .time, .level, .combo {
            text-align: center;
            margin: 5px 10px;
        }
        
        .level {
            color: #e67e22;
            font-weight: bold;
        }
        
        .combo {
            color: #e74c3c;
            font-weight: bold;
        }
        
        #game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            grid-gap: 4px;
            max-width: 500px;
            width: 100%;
            background-color: #e0e0e0;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            position: relative;
            aspect-ratio: 1;
            min-height: 0;
        }
        
        .tile {
            width: 100%;
            height: 100%;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: transform 0.3s ease, opacity 0.3s ease, background-color 0.3s ease;
            font-size: 24px;
            user-select: none;
            position: relative;
            color: #fff;
            background-color: #ddd;
        }
        
        .tile:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }
        
        .selected {
            transform: scale(1.1);
            box-shadow: 0 0 10px gold;
        }
        
        .removing {
            animation: remove-animation 0.5s ease-out;
        }
        
        .dropping {
            animation: drop-animation 0.5s ease-in;
        }
        
        .new-tile {
            animation: new-tile-animation 0.5s ease-out;
        }
        
        @keyframes remove-animation {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); }
            100% { transform: scale(0); opacity: 0; }
        }
        
        @keyframes drop-animation {
            from { transform: translateY(-100%); }
            to { transform: translateY(0); }
        }
        
        @keyframes new-tile-animation {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 500px;
            width: 100%;
        }
        
        button {
            padding: 10px 20px;
            background-color: #4a90e2;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #3a7bc8;
        }
        
        .score-popup {
            position: absolute;
            color: gold;
            font-weight: bold;
            font-size: 24px;
            z-index: 100;
            text-shadow: 0 0 3px black;
            pointer-events: none;
            animation: score-animation 1s ease-out forwards;
        }
        
        @keyframes score-animation {
            0% { transform: scale(0.5); opacity: 0; }
            10% { transform: scale(1.2); opacity: 1; }
            80% { transform: translateY(-20px) scale(1); opacity: 1; }
            100% { transform: translateY(-30px) scale(1); opacity: 0; }
        }
        
        .progress-container {
            width: 100%;
            max-width: 500px;
            background-color: #e0e0e0;
            height: 10px;
            border-radius: 5px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #4caf50;
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .level-up {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: gold;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 48px;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        
        .level-up.show {
            opacity: 1;
        }
        
        .rules {
            margin-top: 20px;
            max-width: 500px;
            width: 100%;
            text-align: center;
            font-size: 14px;
            color: #666;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 5px;
            border-radius: 5px;
        }
        
        /* 自定义蒙版弹窗样式 */
        .game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .game-over-modal.show {
            opacity: 1;
            pointer-events: auto;
        }
        
        .game-over-content {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        .game-over-content p {
            margin: 10px 0;
            font-size: 18px;
            color: #333;
        }
        
        .game-over-content button {
            margin-top: 15px;
            background-color: #ff6b6b;
        }
        
        .game-over-content button:hover {
            background-color: #e55a5a;
        }
        
        @media (max-width: 500px) {
            #game-board {
                grid-gap: 2px;
                padding: 5px;
            }
            
            .tile {
                font-size: 18px;
            }
            
            .game-info {
                font-size: 14px;
            }
            
            .score-popup {
                font-size: 18px;
            }
            
            .rules {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1 id="game-title">开心消消乐</h1>
        
        <div class="language-selector">
            <button class="language-btn active" data-lang="zh-CN">简体中文</button>
            <button class="language-btn" data-lang="zh-TW">繁體中文</button>
            <button class="language-btn" data-lang="en">English</button>
            <button class="language-btn" data-lang="ko">한국어</button>
            <button class="language-btn" data-lang="ja">日本語</button>
        </div>
    </header>
    
    <div class="game-info">
        <div class="level" id="level-display">关卡: <span id="level">1</span>/100</div>
        <div class="score" id="score-display">得分: <span id="score">0</span></div>
        <div class="moves" id="moves-display">步数: <span id="moves">0</span></div>
        <div class="time" id="time-display">时间: <span id="time">60</span>s</div>
        <div class="combo" id="combo-display">连击: <span id="combo">0</span>x</div>
    </div>
    
    <div class="progress-container">
        <div class="progress-bar" id="level-progress"></div>
    </div>
    
    <div id="game-board"></div>
    
    <div class="controls">
        <button id="new-game" class="control-btn">新游戏</button>
        <button id="hint" class="control-btn">提示</button>
    </div>
    
    <div class="rules">
        规则：交换相邻水果，3个或以上相同水果连成一线即可消除。得分达标升级，时间耗尽游戏结束。
    </div>
    
    <div class="level-up" id="level-up-display">
        <div id="level-up-text">升级到第 2 关！</div>
    </div>
    
    <!-- 自定义游戏结束蒙版弹窗 -->
    <div class="game-over-modal" id="game-over-modal">
        <div class="game-over-content">
            <p id="game-over-text"></p>
            <p id="game-over-score"></p>
            <p id="game-over-moves"></p>
            <p>请点击下方按钮重新开始！</p>
            <button onclick="initGame(); document.getElementById('game-over-modal').classList.remove('show');">重新开始</button>
        </div>
    </div>
    
    <script>
        // 多语言支持
        const translations = {
            'zh-CN': {
                title: '开心消消乐',
                level: '关卡',
                score: '得分',
                moves: '步数',
                time: '时间',
                combo: '连击',
                newGame: '新游戏',
                hint: '提示',
                gameOver: '游戏结束！',
                yourScore: '你的得分',
                usedMoves: '使用的步数',
                levelUp: '升级到第 {level} 关！'
            },
            'zh-TW': {
                title: '開心消消樂',
                level: '關卡',
                score: '得分',
                moves: '步數',
                time: '時間',
                combo: '連擊',
                newGame: '新遊戲',
                hint: '提示',
                gameOver: '遊戲結束！',
                yourScore: '你的得分',
                usedMoves: '使用的步數',
                levelUp: '升級到第 {level} 關！'
            },
            'en': {
                title: 'Happy Match-3',
                level: 'Level',
                score: 'Score',
                moves: 'Moves',
                time: 'Time',
                combo: 'Combo',
                newGame: 'New Game',
                hint: 'Hint',
                gameOver: 'Game Over!',
                yourScore: 'Your Score',
                usedMoves: 'Moves Used',
                levelUp: 'Level Up to {level}!'
            },
            'ko': {
                title: '해피 매치-3',
                level: '레벨',
                score: '점수',
                moves: '이동',
                time: '시간',
                combo: '콤보',
                newGame: '새 게임',
                hint: '힌트',
                gameOver: '게임 오버!',
                yourScore: '당신의 점수',
                usedMoves: '사용된 이동',
                levelUp: '레벨 {level} 업!'
            },
            'ja': {
                title: 'ハッピーマッチ３',
                level: 'レベル',
                score: 'スコア',
                moves: '手数',
                time: '時間',
                combo: 'コンボ',
                newGame: '新しいゲーム',
                hint: 'ヒント',
                gameOver: 'ゲームオーバー！',
                yourScore: 'あなたのスコア',
                usedMoves: '使用した手数',
                levelUp: 'レベル {level} にアップ！'
            }
        };
        
        let currentLang = 'zh-CN';
        
        // 游戏配置
        const config = {
            rows: 8,
            cols: 8,
            types: ["🍎", "🍊", "🍋", "🍇", "🍉", "🍓"],
            minMatch: 3,
            timeLimit: 60,
            animationDuration: 500,
            baseScorePerTile: 10,
            comboMultiplier: 0.5,
            maxLevel: 100,
            scoreToLevelUp: 1000
        };
        
        // 游戏状态
        let gameState = {
            board: [],
            visualBoard: [],
            score: 0,
            totalScore: 0,
            levelScore: 0,
            level: 1,
            moves: 0,
            selected: null,
            timeRemaining: config.timeLimit,
            timer: null,
            gameOver: false,
            animating: false,
            combo: 0,
            comboTimeout: null,
            nextLevelScore: config.scoreToLevelUp
        };
        
        // DOM元素
        let boardElement = document.getElementById("game-board");
        let scoreElement = document.getElementById("score");
        let movesElement = document.getElementById("moves");
        let timeElement = document.getElementById("time");
        let newGameButton = document.getElementById("new-game");
        let hintButton = document.getElementById("hint");
        let levelElement = document.getElementById("level");
        let comboElement = document.getElementById("combo");
        let progressBar = document.getElementById("level-progress");
        let levelUpDisplay = document.getElementById("level-up-display");
        let levelUpText = document.getElementById("level-up-text");
        let gameOverModal = document.getElementById("game-over-modal");
        
        // 水果消除音效（Freesound 的 Bubble Pop）
        const eliminateSound = new Audio('https://freesound.org/data/previews/264/264941_4332392-lq.mp3');
        
        // 语言选择器事件
        const languageButtons = document.querySelectorAll('.language-btn');
        languageButtons.forEach(button => {
            button.addEventListener('click', () => {
                currentLang = button.dataset.lang;
                languageButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                updateUIText();
            });
        });
        
        // 更新界面文本
        function updateUIText() {
            const t = translations[currentLang];
            document.getElementById('game-title').textContent = t.title;
            document.getElementById('level-display').innerHTML = `${t.level}: <span id="level">${gameState.level}</span>/100`;
            document.getElementById('score-display').innerHTML = `${t.score}: <span id="score">${gameState.totalScore}</span>`;
            document.getElementById('moves-display').innerHTML = `${t.moves}: <span id="moves">${gameState.moves}</span>`;
            document.getElementById('time-display').innerHTML = `${t.time}: <span id="time">${gameState.timeRemaining}</span>s`;
            document.getElementById('combo-display').innerHTML = `${t.combo}: <span id="combo">${gameState.combo}</span>x`;
            document.getElementById('new-game').textContent = t.newGame;
            document.getElementById('hint').textContent = t.hint;
            levelElement = document.getElementById("level");
            scoreElement = document.getElementById("score");
            movesElement = document.getElementById("moves");
            timeElement = document.getElementById("time");
            comboElement = document.getElementById("combo");
        }
        
        // 初始化游戏
        function initGame() {
            gameState = {
                board: [],
                visualBoard: [],
                score: 0,
                totalScore: 0,
                levelScore: 0,
                level: 1,
                moves: 0,
                selected: null,
                timeRemaining: config.timeLimit,
                timer: null,
                gameOver: false,
                animating: false,
                combo: 0,
                comboTimeout: null,
                nextLevelScore: config.scoreToLevelUp
            };
            
            clearTimeout(gameState.comboTimeout);
            if (gameState.timer) clearInterval(gameState.timer);
            updateUIText();
            scoreElement.textContent = "0";
            movesElement.textContent = "0";
            timeElement.textContent = config.timeLimit;
            levelElement.textContent = "1";
            comboElement.textContent = "0";
            updateProgressBar();
            
            createBoard();
            gameState.visualBoard = JSON.parse(JSON.stringify(gameState.board));
            renderBoard();
            startTimer();
        }
        
        // 创建游戏板
        function createBoard() {
            for (let row = 0; row < config.rows; row++) {
                gameState.board[row] = [];
                for (let col = 0; col < config.cols; col++) {
                    let type;
                    do {
                        type = getRandomTileType();
                        gameState.board[row][col] = type;
                    } while (checkInitialMatches(row, col));
                }
            }
            while (!hasPossibleMoves()) {
                createBoard();
            }
        }
        
        // 获取随机瓷砖类型
        function getRandomTileType() {
            const availableTypes = Math.min(3 + Math.floor(gameState.level / 10), config.types.length);
            return config.types[Math.floor(Math.random() * availableTypes)];
        }
        
        // 检查初始匹配
        function checkInitialMatches(row, col) {
            if (col >= 2) {
                if (gameState.board[row][col] === gameState.board[row][col-1] && 
                    gameState.board[row][col] === gameState.board[row][col-2]) {
                    return true;
                }
            }
            if (row >= 2) {
                if (gameState.board[row][col] === gameState.board[row-1][col] && 
                    gameState.board[row][col] === gameState.board[row-2][col]) {
                    return true;
                }
            }
            return false;
        }
        
        // 渲染游戏板
        function renderBoard() {
            boardElement.innerHTML = "";
            for (let row = 0; row < config.rows; row++) {
                for (let col = 0; col < config.cols; col++) {
                    const tile = document.createElement("div");
                    tile.className = "tile";
                    tile.dataset.row = row;
                    tile.dataset.col = col;
                    
                    const type = gameState.visualBoard[row]?.[col] || gameState.board[row][col];
                    tile.textContent = type;
                    
                    const colors = {
                        "🍎": "#ff6b6b",
                        "🍊": "#ffa94d",
                        "🍋": "#ffe066",
                        "🍇": "#cc5de8",
                        "🍉": "#20c997",
                        "🍓": "#ff8787"
                    };
                    tile.style.backgroundColor = colors[type] || "#ddd";
                    
                    if (gameState.selected && 
                        gameState.selected.row === row && 
                        gameState.selected.col === col) {
                        tile.classList.add("selected");
                    }
                    
                    tile.addEventListener("click", () => {
                        if (gameState.gameOver || gameState.animating) return;
                        handleTileClick(row, col);
                    });
                    
                    boardElement.appendChild(tile);
                }
            }
        }
        
        // 处理瓷砖点击
        function handleTileClick(row, col) {
            if (gameState.selected) {
                const selectedRow = gameState.selected.row;
                const selectedCol = gameState.selected.col;
                if (isAdjacent(row, col, selectedRow, selectedCol)) {
                    swapTiles(row, col, selectedRow, selectedCol);
                    gameState.selected = null;
                } else {
                    gameState.selected = { row, col };
                    renderBoard();
                }
            } else {
                gameState.selected = { row, col };
                renderBoard();
            }
        }
        
        // 检查瓷砖是否相邻
        function isAdjacent(row1, col1, row2, col2) {
            return (
                (Math.abs(row1 - row2) === 1 && col1 === col2) ||
                (Math.abs(col1 - col2) === 1 && row1 === row2)
            );
        }
        
        // 交换瓷砖
        function swapTiles(row1, col1, row2, col2) {
            if (gameState.animating) return;
            gameState.animating = true;
            
            const tile1 = document.querySelector(`[data-row="${row1}"][data-col="${col1}"]`);
            const tile2 = document.querySelector(`[data-row="${row2}"][data-col="${col2}"]`);
            
            const tile1Rect = tile1.getBoundingClientRect();
            const tile2Rect = tile2.getBoundingClientRect();
            const deltaX = tile2Rect.left - tile1Rect.left;
            const deltaY = tile2Rect.top - tile1Rect.top;
            
            tile1.style.zIndex = "10";
            tile2.style.zIndex = "10";
            tile1.style.transition = `transform 0.3s ease`;
            tile2.style.transition = `transform 0.3s ease`;
            tile1.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            tile2.style.transform = `translate(${-deltaX}px, ${-deltaY}px)`;
            
            const temp = gameState.board[row1][col1];
            gameState.board[row1][col1] = gameState.board[row2][col2];
            gameState.board[row2][col2] = temp;
            gameState.visualBoard = JSON.parse(JSON.stringify(gameState.board));
            
            setTimeout(() => {
                const matches = findMatches();
                if (matches.length > 0) {
                    gameState.moves++;
                    movesElement.textContent = gameState.moves;
                    removeMatchesWithAnimation(matches);
                } else {
                    const temp = gameState.board[row1][col1];
                    gameState.board[row1][col1] = gameState.board[row2][col2];
                    gameState.board[row2][col2] = temp;
                    gameState.visualBoard = JSON.parse(JSON.stringify(gameState.board));
                    tile1.style.transform = "";
                    tile2.style.transform = "";
                    setTimeout(() => {
                        renderBoard();
                        gameState.animating = false;
                        resetCombo();
                    }, 300);
                }
            }, 300);
        }
        
        // 查找匹配
        function findMatches() {
            const matches = [];
            for (let row = 0; row < config.rows; row++) {
                for (let col = 0; col < config.cols - 2; col++) {
                    const type = gameState.board[row][col];
                    if (!type) continue;
                    let matchLength = 1;
                    let nextCol = col + 1;
                    while (nextCol < config.cols && gameState.board[row][nextCol] === type) {
                        matchLength++;
                        nextCol++;
                    }
                    if (matchLength >= config.minMatch) {
                        const match = { type: 'horizontal', row, col, length: matchLength, positions: [] };
                        for (let i = 0; i < matchLength; i++) {
                            match.positions.push({ row, col: col + i });
                        }
                        matches.push(match);
                    }
                }
            }
            for (let col = 0; col < config.cols; col++) {
                for (let row = 0; row < config.rows - 2; row++) {
                    const type = gameState.board[row][col];
                    if (!type) continue;
                    let matchLength = 1;
                    let nextRow = row + 1;
                    while (nextRow < config.rows && gameState.board[nextRow][col] === type) {
                        matchLength++;
                        nextRow++;
                    }
                    if (matchLength >= config.minMatch) {
                        const match = { type: 'vertical', row, col, length: matchLength, positions: [] };
                        for (let i = 0; i < matchLength; i++) {
                            match.positions.push({ row: row + i, col });
                        }
                        matches.push(match);
                    }
                }
            }
            return matches;
        }
        
        // 移除匹配的瓷砖并播放音效
        function removeMatchesWithAnimation(matches) {
            let totalRemoved = 0;
            const tilesToRemove = new Set();
            matches.forEach(match => {
                match.positions.forEach(pos => {
                    const key = `${pos.row}-${pos.col}`;
                    if (!tilesToRemove.has(key)) {
                        tilesToRemove.add(key);
                        totalRemoved++;
                    }
                });
            });
            
            updateCombo();
            const comboMultiplier = 1 + (gameState.combo - 1) * config.comboMultiplier;
            const points = Math.floor(config.baseScorePerTile * totalRemoved * comboMultiplier);
            const matchCenter = calculateMatchCenter(matches);
            showScorePopup(points, matchCenter.x, matchCenter.y);
            
            gameState.score += points;
            gameState.totalScore += points;
            gameState.levelScore += points;
            scoreElement.textContent = gameState.totalScore;
            checkLevelUp();
            
            // 播放水果消除音效
            eliminateSound.play();
            
            tilesToRemove.forEach(key => {
                const [row, col] = key.split('-').map(Number);
                const tile = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (tile) tile.classList.add('removing');
                gameState.board[row][col] = null;
            });
            
            setTimeout(() => {
                dropTilesWithAnimation();
            }, config.animationDuration);
        }
        
        // 计算匹配中心点
        function calculateMatchCenter(matches) {
            let totalX = 0, totalY = 0, count = 0;
            matches.forEach(match => {
                match.positions.forEach(pos => {
                    const tile = document.querySelector(`[data-row="${pos.row}"][data-col="${pos.col}"]`);
                    if (tile) {
                        const rect = tile.getBoundingClientRect();
                        totalX += rect.left + rect.width / 2;
                        totalY += rect.top + rect.height / 2;
                        count++;
                    }
                });
            });
            return { x: totalX / count, y: totalY / count };
        }
        
        // 显示得分弹出
        function showScorePopup(score, x, y) {
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            popup.textContent = `+${score}`;
            popup.style.left = `${x}px`;
            popup.style.top = `${y}px`;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 1000);
        }
        
        // 更新连击
        function updateCombo() {
            clearTimeout(gameState.comboTimeout);
            gameState.combo++;
            comboElement.textContent = gameState.combo;
            gameState.comboTimeout = setTimeout(resetCombo, 2000);
        }
        
        // 重置连击
        function resetCombo() {
            clearTimeout(gameState.comboTimeout);
            gameState.combo = 0;
            comboElement.textContent = gameState.combo;
        }
        
        // 检查升级
        function checkLevelUp() {
            updateProgressBar();
            if (gameState.levelScore >= gameState.nextLevelScore && gameState.level < config.maxLevel) {
                levelUp();
            }
        }
        
        // 升级
        function levelUp() {
            gameState.level++;
            gameState.levelScore = 0;
            gameState.nextLevelScore = Math.floor(config.scoreToLevelUp * Math.pow(1.2, gameState.level - 1));
            levelElement.textContent = gameState.level;
            updateProgressBar();
            
            const t = translations[currentLang];
            levelUpText.textContent = t.levelUp.replace('{level}', gameState.level);
            levelUpDisplay.classList.add('show');
            setTimeout(() => levelUpDisplay.classList.remove('show'), 2000);
            
            gameState.timeRemaining = config.timeLimit;
            timeElement.textContent = gameState.timeRemaining;
        }
        
        // 更新进度条
        function updateProgressBar() {
            const progress = (gameState.levelScore / gameState.nextLevelScore) * 100;
            progressBar.style.width = `${Math.min(progress, 100)}%`;
        }
        
        // 下落瓷砖
        function dropTilesWithAnimation() {
            const columnsToProcess = [];
            for (let col = 0; col < config.cols; col++) {
                const colInfo = { col, drops: [], newTiles: [] };
                let emptySpaces = 0;
                for (let row = config.rows - 1; row >= 0; row--) {
                    if (gameState.board[row][col] === null) {
                        emptySpaces++;
                    } else if (emptySpaces > 0) {
                        colInfo.drops.push({
                            fromRow: row,
                            toRow: row + emptySpaces,
                            type: gameState.board[row][col]
                        });
                        gameState.board[row + emptySpaces][col] = gameState.board[row][col];
                        gameState.board[row][col] = null;
                    }
                }
                for (let row = 0; row < emptySpaces; row++) {
                    const type = getRandomTileType();
                    colInfo.newTiles.push({ row, type });
                    gameState.board[row][col] = type;
                }
                columnsToProcess.push(colInfo);
            }
            
            gameState.visualBoard = JSON.parse(JSON.stringify(gameState.board));
            columnsToProcess.forEach(colInfo => {
                colInfo.drops.forEach(drop => {
                    gameState.visualBoard[drop.fromRow][colInfo.col] = drop.type;
                    gameState.visualBoard[drop.toRow][colInfo.col] = null;
                });
                colInfo.newTiles.forEach(newTile => {
                    gameState.visualBoard[newTile.row][colInfo.col] = null;
                });
            });
            
            renderBoard();
            
            setTimeout(() => {
                columnsToProcess.forEach(colInfo => {
                    colInfo.drops.forEach(drop => {
                        const tile = document.querySelector(`[data-row="${drop.fromRow}"][data-col="${colInfo.col}"]`);
                        if (tile) {
                            tile.classList.add('dropping');
                            const distance = (drop.toRow - drop.fromRow) * (tile.offsetHeight + 4);
                            tile.style.transform = `translateY(${distance}px)`;
                        }
                    });
                });
                
                setTimeout(() => {
                    gameState.visualBoard = JSON.parse(JSON.stringify(gameState.board));
                    renderBoard();
                    columnsToProcess.forEach(colInfo => {
                        colInfo.newTiles.forEach(newTile => {
                            const tile = document.querySelector(`[data-row="${newTile.row}"][data-col="${colInfo.col}"]`);
                            if (tile) tile.classList.add('new-tile');
                        });
                    });
                    
                    setTimeout(() => {
                        const newMatches = findMatches();
                        if (newMatches.length > 0) {
                            removeMatchesWithAnimation(newMatches);
                        } else if (!hasPossibleMoves()) {
                            shuffleBoard();
                            gameState.animating = false;
                        } else {
                            gameState.animating = false;
                        }
                    }, config.animationDuration);
                }, config.animationDuration);
            }, 50);
        }
        
        // 检查是否有可能的移动
        function hasPossibleMoves() {
            const tempBoard = gameState.board.map(row => [...row]);
            for (let row = 0; row < config.rows; row++) {
                for (let col = 0; col < config.cols; col++) {
                    if (col < config.cols - 1) {
                        [gameState.board[row][col], gameState.board[row][col+1]] = 
                        [gameState.board[row][col+1], gameState.board[row][col]];
                        const matches = findMatches();
                        [gameState.board[row][col], gameState.board[row][col+1]] = 
                        [gameState.board[row][col+1], gameState.board[row][col]];
                        if (matches.length > 0) {
                            gameState.board = tempBoard.map(row => [...row]);
                            return true;
                        }
                    }
                    if (row < config.rows - 1) {
                        [gameState.board[row][col], gameState.board[row+1][col]] = 
                        [gameState.board[row+1][col], gameState.board[row][col]];
                        const matches = findMatches();
                        [gameState.board[row][col], gameState.board[row+1][col]] = 
                        [gameState.board[row+1][col], gameState.board[row][col]];
                        if (matches.length > 0) {
                            gameState.board = tempBoard.map(row => [...row]);
                            return true;
                        }
                    }
                }
            }
            gameState.board = tempBoard.map(row => [...row]);
            return false;
        }
        
        // 洗牌游戏板
        function shuffleBoard() {
            if (gameState.animating) return;
            gameState.animating = true;
            
            const allTiles = [];
            for (let row = 0; row < config.rows; row++) {
                for (let col = 0; col < config.cols; col++) {
                    allTiles.push(gameState.board[row][col]);
                }
            }
            for (let i = allTiles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allTiles[i], allTiles[j]] = [allTiles[j], allTiles[i]];
            }
            
            let index = 0;
            for (let row = 0; row < config.rows; row++) {
                for (let col = 0; col < config.cols; col++) {
                    gameState.board[row][col] = allTiles[index++];
                }
            }
            
            if (!hasPossibleMoves()) {
                shuffleBoard();
                return;
            }
            
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.style.transition = "transform 0.5s ease, opacity 0.2s ease";
                tile.style.transform = "scale(0)";
                tile.style.opacity = "0";
            });
            
            setTimeout(() => {
                gameState.visualBoard = JSON.parse(JSON.stringify(gameState.board));
                renderBoard();
                setTimeout(() => {
                    const newTiles = document.querySelectorAll('.tile');
                    newTiles.forEach(tile => tile.classList.add('new-tile'));
                    setTimeout(() => gameState.animating = false, config.animationDuration);
                }, 50);
            }, 500);
        }
        
        // 开始计时器
        function startTimer() {
            if (gameState.timer) clearInterval(gameState.timer);
            gameState.timer = setInterval(() => {
                gameState.timeRemaining--;
                timeElement.textContent = gameState.timeRemaining;
                if (gameState.timeRemaining <= 0) {
                    clearInterval(gameState.timer);
                    endGame();
                }
            }, 1000);
        }
        
        // 结束游戏（使用蒙版弹窗）
        function endGame() {
            clearInterval(gameState.timer);
            gameState.gameOver = true;
            const t = translations[currentLang];
            document.getElementById('game-over-text').textContent = t.gameOver;
            document.getElementById('game-over-score').textContent = `${t.yourScore}: ${gameState.totalScore}`;
            document.getElementById('game-over-moves').textContent = `${t.usedMoves}: ${gameState.moves}`;
            gameOverModal.classList.add('show');
        }
        
        // 提示功能
        function showHint() {
            if (gameState.gameOver || gameState.animating) return;
            for (let row = 0; row < config.rows; row++) {
                for (let col = 0; col < config.cols; col++) {
                    if (col < config.cols - 1) {
                        [gameState.board[row][col], gameState.board[row][col+1]] = 
                        [gameState.board[row][col+1], gameState.board[row][col]];
                        const matches = findMatches();
                        [gameState.board[row][col], gameState.board[row][col+1]] = 
                        [gameState.board[row][col+1], gameState.board[row][col]];
                        if (matches.length > 0) {
                            const tile1 = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                            const tile2 = document.querySelector(`[data-row="${row}"][data-col="${col+1}"]`);
                            if (tile1 && tile2) {
                                tile1.classList.add("selected");
                                tile2.classList.add("selected");
                                setTimeout(() => {
                                    tile1.classList.remove("selected");
                                    tile2.classList.remove("selected");
                                }, 1000);
                            }
                            return;
                        }
                    }
                    if (row < config.rows - 1) {
                        [gameState.board[row][col], gameState.board[row+1][col]] = 
                        [gameState.board[row+1][col], gameState.board[row][col]];
                        const matches = findMatches();
                        [gameState.board[row][col], gameState.board[row+1][col]] = 
                        [gameState.board[row+1][col], gameState.board[row][col]];
                        if (matches.length > 0) {
                            const tile1 = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                            const tile2 = document.querySelector(`[data-row="${row+1}"][data-col="${col}"]`);
                            if (tile1 && tile2) {
                                tile1.classList.add("selected");
                                tile2.classList.add("selected");
                                setTimeout(() => {
                                    tile1.classList.remove("selected");
                                    tile2.classList.remove("selected");
                                }, 1000);
                            }
                            return;
                        }
                    }
                }
            }
        }
        
        // 事件监听器
        newGameButton.addEventListener("click", initGame);
        hintButton.addEventListener("click", showHint);
        
        // 初始化游戏
        initGame();
    </script>
</body>
</html>